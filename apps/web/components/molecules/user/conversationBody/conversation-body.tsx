"use client";
import React, { useState, useEffect } from 'react';
import MessageList from './message-list';
import PromptTextInput from './prompt-text-input';
import { useChat, } from "ai/react"
import type { Message } from "ai/react"
import { Sender, type Message as WizepromptMessage } from "@prisma/client";
import type { UseChatOptions } from "ai";
import { encode } from 'gpt-tokenizer';
import type { MessageDataInput } from "@/lib/message";


const providerImage =
    "https://avatars.githubusercontent.com/u/86160567?s=200&v=4"; // URL de la imagen del remitente

// FunciÃ³n dummy para simular el callback de copiar mensaje
/*
const Callback = (message: Message) => {
  console.log("Mensaje copiado:", message.content);
};
*/
const userImage = "https://ui-avatars.com/api/?background=007CFF&color=fff&name=David";

interface ExtendedUseChatOptions extends UseChatOptions {
    messages: Message[];
    temperature: number;
    customInstructions: string;
}

function calculateTokens(input: string): number {
    const tokens: number[] = encode(input)
    return tokens.length
}

function calculateCredits(tokens: number, model: string, isInput: boolean): number {
    // Checks if the message was user created or output by the model to determine the price
    let price: number
    if (isInput) {
        price = model === 'gpt-3.5-turbo' ? Number(process.env.NEXT_PUBLIC_GPT_35_INPUT) : Number(process.env.NEXT_PUBLIC_GPT_4_INPUT)
    } else {
        price = model === 'gpt-3.5-turbo' ? Number(process.env.NEXT_PUBLIC_GPT_35_OUTPUT) : Number(process.env.NEXT_PUBLIC_GPT_4_OUTPUT)
    }
    // GPT pricing per 1000 tokens
    return (tokens / 1000) * price
}

async function saveMessage(message: MessageDataInput): Promise<void> {
    try {
        await fetch('/api/messages', {
            method: 'POST',
            body: JSON.stringify(message)
        });
    } catch {
        console.log("Error ocurred while saving message.")
    }
}

function convertToGptMessage(item: WizepromptMessage): Message {
    const role: "function" | "user" | "assistant" | "system" = item.sender === "USER" ? "user" : "assistant";
    return {
        id: String(item.id),
        role,
        content: item.content,
    };
}

export default function ConversationBody(): JSX.Element {
    const [messageData, setMessageData] = useState<Message[]>([])
   // const [wizepromptMessageData, setWizepromptMessageData] = useState<WizepromptMessage[]>([])

    // Function that fetches data from messages api route and 
    // sets the content of a message to the first content instance
    const getData: () => Promise<void> = async () => {
        const response: Response = await fetch('/api/messages/conversation/1');
        const data: WizepromptMessage[] = await response.json();
        const processedData: Message[] = data.map(convertToGptMessage);
        setMessageData(processedData);
        //setWizepromptMessageData(data);
    };


    useEffect(() => {
        void getData()
    })

    const options: ExtendedUseChatOptions = {
        api: '/api/ai/openai/gpt-4',
        initialMessages: messageData,
        messages: messageData,
        temperature: 0.5,
        customInstructions: "",
        // onFinish callback function that runss when the response stream is finished
        // Saves the message generated by the model
        onFinish(message) {
            const tokens: number = calculateTokens(message.content)
            const messageInfo: MessageDataInput = {
                idConversation: 1,
                content: message.content,
                sender: message.role === 'user' ? Sender.USER : Sender.MODEL,
                creditsUsed: calculateCredits(tokens, 'gpt-3.5-turbo', false)
            }
            void saveMessage(messageInfo)
        },
    };

    // set api route that handleSubmit will use and load initial messages
    const {
        input, // The current value of the input field.
        handleInputChange, // Handler for the onChange event of the input field to control the input's value.
        handleSubmit, // Form submission handler that automatically resets the input field and appends a user message.
        messages, // The current array of chat messages.
        /*
       isLoading, // Boolean flag indicating whether a request is currently in progress.
       stop, // Function that aborts the current request
       reload,//Function to reload the last AI chat response for the given chat history.
       append, //append(message: Message | CreateMessage, chatRequestOptions: { options: { headers, body } }) Function to append a message to the chat, triggering an API call for the AI response.
       error, //An error object returned by SWR, if any.
       */
    } = useChat(options);



    return (
        <div className="pb-36">
            <MessageList messages={messages} providerImage={providerImage} userImage={userImage} />
            <PromptTextInput input={input} handleInputChange={handleInputChange} handleSubmit={handleSubmit} />
        </div>
    );
}
